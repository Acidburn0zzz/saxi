<!DOCTYPE html>
<html>
  <head>
    <title>saxi</title>
    <script src="/js/path-data-polyfill.js"></script>
    <script src="/js/driver.js"></script>
<style>
path {
  stroke: black;
  fill: transparent;
}
svg {
  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);
}
</style>
  </head>
  <body>
    <div>
      pen up:
      <input type="number" id="penUpHeight" min="0" max="100" value="50"/>
    </div>
    <div>
      pen down:
      <input type="number" id="penDownHeight" min="0" max="100" value="60"/>
    </div>
    <div>
      <button id="penUp">pen up</button>
      <button id="penDown">pen down</button>
    </div>
    <div>
      <select id="paperSizeSelector">
      </select>
      <input type="number" id="paperSizeWidth"/> &times; <input type="number" id="paperSizeHeight"/> mm
      <label><input type="checkbox" checked id="landscape"> landscape</label>
    </div>
    <div>
      margin: <input type="number" id="marginMm" value="20"/> mm
    </div>
    <div>
      <button id="limp">limp</button>
    </div>
    <div id="stats"></div>
    <div>
      <svg id="planPreview" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
    </div>
    <div>
      <button id="doPlot" disabled>plot</button>
      <button id="doCancel">cancel</button>
    </div>
    <script>
      const svgNS = "http://www.w3.org/2000/svg";  
      Object.keys(Planning.paperSizes).forEach(name => {
        const option = document.createElement('option')
        option.textContent = name
        paperSizeSelector.appendChild(option)
      })
      function setPaperSize(ps) {
        paperSizeWidth.value = ps.size.x
        paperSizeHeight.value = ps.size.y
        planPreview.setAttribute('width', ps.size.x * scale)
        planPreview.setAttribute('height', ps.size.y * scale)
        planPreview.setAttribute('viewBox', `0 0 ${ps.size.x} ${ps.size.y}`)
      }
      paperSizeSelector.addEventListener('change', e => {
        let ps = Planning.paperSizes[e.target.value]
        if (landscape.checked) ps = ps.landscape
        else ps = ps.portrait
        setPaperSize(ps)
      })
      landscape.addEventListener('change', e => {
        let ps = PaperSize(Vec2(Number(paperSizeWidth.value), Number(paperSizeHeight.value)))
        if (landscape.checked) ps = ps.landscape
        else ps = ps.portrait
        setPaperSize(ps)
      })
      paperSizeSelector.value = 'ArchA'

      const scale = 3 /* px/mm */

      document.body.addEventListener('drop', e => {
        e.preventDefault()
        const item = e.dataTransfer.items[0]
        const file = item.getAsFile()
        const reader = new FileReader()
        reader.onload = e => readSvg(reader.result)
        reader.readAsText(file)
      })
      document.body.addEventListener('dragover', e => {
        e.preventDefault()
      })

      setPaperSize(Planning.paperSizes.ArchA.landscape)

      function isFlatEnough([x0, y0, x1, y1, x2, y2, x3, y3], flatness) {
        // https://github.com/paperjs/paper.js/blob/a61e83edf2ed1870bd41bad135f4f6fc85b0f628/src/path/Curve.js#L806
        const ux = 3 * x1 - 2 * x0 - x3,
              uy = 3 * y1 - 2 * y0 - y3,
              vx = 3 * x2 - 2 * x3 - x0,
              vy = 3 * y2 - 2 * y3 - y0;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
                <= 16 * flatness * flatness;
      }

      function subdivide([x0, y0, x1, y1, x2, y2, x3, y3], t) {
        // https://github.com/paperjs/paper.js/blob/a61e83edf2ed1870bd41bad135f4f6fc85b0f628/src/path/Curve.js#L606
        if (t === undefined)
            t = 0.5;
        // Triangle computation, with loops unrolled.
        let u = 1 - t,
            // Interpolate from 4 to 3 points
            x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
            x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
            x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
            // Interpolate from 3 to 2 points
            x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
            x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
            // Interpolate from 2 points to 1 point
            x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
        // We now have all the values we need to build the sub-curves:
        return [
            [x0, y0, x4, y4, x7, y7, x9, y9], // left
            [x9, y9, x8, y8, x6, y6, x3, y3] // right
        ];
      }

      function flatten(v, flatness, maxRecursion) {
        const minSpan = 1 / (maxRecursion || 32)
        const parts = []

        function computeParts(curve, t1, t2) {
          if ((t2 - t1) > minSpan && !isFlatEnough(curve, flatness) /* && !isStraight(curve) */) {
            const halves = subdivide(curve, 0.5);
            const tMid = (t1 + t2) / 2;
            computeParts(halves[0], t1, tMid);
            computeParts(halves[1], tMid, t2);
          } else {
            const dx = curve[6] - curve[0];
            const dy = curve[7] - curve[1];
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
              parts.push(curve)
            }
          }
        }

        computeParts(v, 0, 1)

        return parts
      }

      function svgToPaths(svgString) {
        const div = document.createElement('div')
        div.style.position = 'absolute'
        div.style.left = '99999px'
        document.body.appendChild(div)
        try {
          div.innerHTML = svgString
          const svg = div.querySelector('svg')
          const svgPoint = svg.createSVGPoint()
          const paths = []
          for (const path of svg.querySelectorAll('path,ellipse')) {
            const type = path.nodeName.toLowerCase()
            const ctm = path.getCTM()
            const xf = ([x,y]) => { svgPoint.x = x; svgPoint.y = y;
              const xfd = svgPoint.matrixTransform(ctm); return [xfd.x, xfd.y] }
            let pathData;
            if (type === 'path') {
              pathData = path.getPathData({normalize: true})
            } else if (type === 'ellipse') {
              const cx = path.cx.baseVal.value
              const cy = path.cy.baseVal.value
              const rx = path.rx.baseVal.value
              const ry = path.ry.baseVal.value
              pathData = [
                {type: 'M', values: [cx-rx, cy]},
                {type: 'A', values: [rx, ry, 0, 1, 0, cx+rx, cy]},
                {type: 'A', values: [rx, ry, 0, 1, 0, cx-rx, cy]},
                {type: 'Z'},
              ]
            }
            let cur = null
            let closePoint = null
            for (const cmd of pathData) {
              if (cmd.type === 'M') {
                cur = xf(cmd.values)
                closePoint = cur
                paths.push([cur])
              } else if (cmd.type === 'L') {
                cur = xf(cmd.values)
                paths[paths.length-1].push(cur)
              } else if (cmd.type === 'C') {
                const [x1, y1, x2, y2, x3, y3] = cmd.values
                const [x0, y0] = cur
                const [tx1, ty1] = xf([x1, y1])
                const [tx2, ty2] = xf([x2, y2])
                const [tx3, ty3] = xf([x3, y3])
                const parts = flatten([x0, y0, tx1, ty1, tx2, ty2, tx3, ty3], 0.1)
                for (const part of parts) {
                  paths[paths.length-1].push([part[6], part[7]])
                }
                cur = [tx3, ty3]
              } else if (cmd.type === 'A') {
                const [rx, ry, xAxisRotation, largeArc, sweep, x, y] = cmd.values
                const phi = xAxisRotation
                const fS = sweep
                const fA = largeArc
                const {cos, sin, sqrt, sign, acos, abs, ceil} = Math

                // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
                const mpx = (cur[0] - x)/2,
                      mpy = (cur[1] - y)/2
                const x1_ = cos(phi) * mpx + sin(phi) * mpy,
                      y1_ = -sin(phi) * mpx + cos(phi) * mpy
                const rx2 = rx*rx,
                      ry2 = ry*ry
                const x1_2 = x1_*x1_,
                      y1_2 = y1_*y1_
                const k = (fA === fS ? -1 : 1) * sqrt(
                  (rx2*ry2 - rx2*y1_2 - ry2*x1_2) /
                  (rx2*y1_2 + ry2*x1_2)
                )
                const cx_ = k * rx * y1_ / ry,
                      cy_ = k * -ry * x1_ / rx
                const cx = cos(phi) * cx_ - sin(phi) * cy_ + (cur[0] + x)/2,
                      cy = sin(phi) * cx_ + cos(phi) * cy_ + (cur[1] + y)/2
                const ang = (ux, uy, vx, vy) =>
                  (ux*vy - uy*vx < 0 ? -1 : 1) *
                    acos((ux*vx+uy*vy) / sqrt(ux*ux+uy*uy)*sqrt(vx*vx+vy*vy))
                const t1 = ang(1, 0, (x1_-cx_)/rx, (y1_-cy_)/ry)
                const dt_ = ang((x1_-cx_)/rx, (y1_-cy_)/ry, (-x1_-cx_)/rx,
                  (-y1_-cy_)/ry) % (Math.PI*2)
                const dt =
                  fS === 0 && dt_ > 0 ? dt_ - Math.PI*2 :
                  fS === 1 && dt_ < 0 ? dt_ + Math.PI*2 :
                  dt_

                // now:
                // - (cx, cy) is the center of the ellipse
                // - (rx, ry) is the radius
                // - phi is the angle around the x-axis of the current
                //   coordinate system to the x-axis of the ellipse
                // - t1 is the start angle of the elliptical arc prior to the stretch and rotate operations.
                // - t1+dt is the end angle of the elliptical arc prior to the stretch and rotate operations.

                // parameterization:
                // ( x )  =  ( cos phi   -sin phi ) . ( rx cos t )  +  ( cx )
                // ( y )  =  ( sin phi    cos phi )   ( ry sin t )     ( cy )

                // https://i.imgur.com/JORhNjU.jpg
                // maximum error based on maximum deviation from true arc
                const e0 = 0.5
                const n = ceil(abs(dt) / acos(1-e0/rx))

                for (let i = 1; i <= n; i++) {
                  const theta = t1 + dt * i/n
                  const tx = cos(phi) * rx * cos(theta) - sin(phi) * ry * sin(theta) + cx
                  const ty = sin(phi) * rx * cos(theta) + cos(phi) * ry * sin(theta) + cy
                  paths[paths.length-1].push([tx,ty])
                }
                cur = [x, y]
              } else if (cmd.type === 'Z') {
                if (closePoint && (cur[0] !== closePoint[0] || cur[1] !== closePoint[1])) {
                  paths[paths.length-1].push(closePoint)
                }
              } else {
                throw Error("um")
              }
            }
          }
          return paths
        } finally {
          div.remove()
        }
      }

      function timed(name) {
        return f => {
          const t0 = performance.now()
          const v = f()
          const t1 = performance.now()
          console.info(`${name} took ${(t1 - t0)} ms`)
          return v
        }
      }

      function readSvg(svgString) {
        const paperSize = PaperSize(Vec2(Number(paperSizeWidth.value), Number(paperSizeHeight.value)))

        const paths = timed("svgToPaths")(() => svgToPaths(svgString))
        const scaledToPaper = timed("scaledToPaper")(() => Planning.scaleToPaper(paths, paperSize, Number(marginMm.value)))
        const optimized = timed("optimize")(() => Planning.optimize(scaledToPaper))

        const penUpPct = Number(penUpHeight.value)
        const penUpPos = Device.Axidraw.penPctToPos(penUpPct)
        const penDownPct = Number(penDownHeight.value)
        const penDownPos = Device.Axidraw.penPctToPos(penDownPct)
        const {stepsPerMm} = Device.Axidraw
        const inSteps = optimized.map(ps => ps.map(p => [p[0] * stepsPerMm, p[1] * stepsPerMm]))
        const plan = timed("plan")(() => Planning.plan(inSteps, penUpPos, penDownPos))
        setPlan(plan, paperSize)
        window.plan = plan
      }
      document.onpaste = e => {
        e.clipboardData.items[0].getAsString(s => readSvg(s))
      }
      function setPlan(plan, paperSize) {
        const lines = Planning.planPoints(plan)
        window.plan = plan
        planPreview.innerHTML = ""
        planPreview.setAttribute('width', paperSize.size.x * scale)
        planPreview.setAttribute('height', paperSize.size.y * scale)
        planPreview.setAttribute('viewBox', `0 0 ${paperSize.size.x} ${paperSize.size.y}`)
        const g = planPreview.appendChild(document.createElementNS(svgNS, "g"))
        g.setAttribute('transform', `scale(${1 / Device.Axidraw.stepsPerMm})`)
        let i = 0;
        for (const line of lines) {
          const path = document.createElementNS(svgNS, "path")
          let d = `M${line[0].x} ${line[0].y}`
          for (const point of line.slice(1)) {
            d += `L${point.x} ${point.y}`
          }
          path.setAttribute("d", d)
          if (i % 2 == 0) {
            path.style.stroke = 'rgba(0, 0, 0, 0.3)'
            path.style.strokeWidth = 0.5
          }
          g.appendChild(path)
          i += 1
        }

        stats.textContent = `Duration: ${Util.formatDuration(plan.duration)}`
        doPlot.removeAttribute('disabled')
      }
      function plot(plan) {
        const pickled = Driver.picklePlan(plan)
        fetch('/plot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/octet-stream' },
          body: pickled,
        }).then(res => res.json()).then(data => console.log(data))
      }
      function cancel() {
        fetch('/cancel', {
          method: 'POST',
        }).then(res => res.json()).then(data => console.log(data))
      }
      d = Driver.connect()
      penUp.onclick = e => {
        const penUpPct = Number(penUpHeight.value)
        const height = Device.Axidraw.penPctToPos(penUpPct)
        d.setPenHeight(height, 1000)
      }
      penDown.onclick = e => {
        const penDownPct = Number(penDownHeight.value)
        const height = Device.Axidraw.penPctToPos(penDownPct)
        d.setPenHeight(height, 1000)
      }
      limp.onclick = e => {
        d.limp()
      }
      doPlot.onclick = e => {
        plot(plan)
      }
      doCancel.onclick = e => cancel()
    </script>
  </body>
</html>
